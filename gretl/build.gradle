buildscript {
    repositories {
        //mavenLocal()
        maven { url "http://download.osgeo.org/webdav/geotools/" }
        jcenter()
        mavenCentral()
        maven { url "http://jars.interlis.ch" }
    }
    /*
    dependencies {
       classpath "ch.so.agi:gretl:2.0.9999"
    } 
    */   
}

plugins {
    id "ch.so.agi.gretl" version "2.0.80"
    id "de.undercouch.download" version "3.4.3"
    id "com.bmuschko.docker-remote-api" version "4.10.0"
}

//apply plugin: "ch.so.agi.gretl"

import java.nio.file.Paths
import ch.so.agi.gretl.tasks.*

ext {
    dbUriEdit = "jdbc:postgresql://localhost:54321/edit"
    dbUserEdit = "gretl"
    dbPwdEdit = "gretl"

    iliModelLandUsePlans = "SO_Nutzungsplanung_20171118"
    dbSchemaLandUsePlans = "arp_npl"

    iliModelVorschriften = "OeREBKRMvs_V1_1"
    iliModelTransferstruktur = "OeREBKRMtrsfr_V1_1"
    dbSchemaLandUsePlansOerebStaging = "agi_oereb_npl_staging"
}

def pathToTempFolder = System.getProperty("java.io.tmpdir")

def cantonalLegalBasisBaseUrl = "https://s3.eu-central-1.amazonaws.com/ch.so.sk.oereb/"
def cantonalLegalBaseDataSet = "ch.so.sk.gesetze.oereb"

def responsibleOfficesBaseUrl = "https://s3.eu-central-1.amazonaws.com/ch.so.arp.nutzungsplanung.oereb-dev/"
def responsibleOfficesDataSet = "ch.so.arp.nutzungsplanung.zustaendigestelle"

def GROUP = "Datenumbau NPLSO -> Transferstruktur (Staging)"

// Löscht sämtliche Daten aus dem ÖREB-NPL-Staging-Schema in der Edit-DB.
task deleteFromStaging(type: SqlExecutor) {
    description = "Löscht die Daten aus dem Staging-Schema ($dbSchemaLandUsePlansOerebStaging)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    sqlFiles = ["delete_oereb_landuseplans_staging_tables.sql"]
}

// Macht den Datenumbau aus dem kantonalen Modell der NPL in die Transferstruktur im ÖREB-NPL-Staging-Schema.
task insertToStaging(type: SqlExecutor, dependsOn: 'deleteFromStaging') {
    description = "Baut die Daten aus dem kantonalen Modell in das Rahmenmodell um und speichert sie im Staging-Schema ($dbSchemaLandUsePlansOerebStaging)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    //sqlFiles = ["wip-insert_oereb_landuseplans_staging_tables.sql"]
    sqlFiles = ["insert_oereb_landuseplans_staging_tables.sql"]
}

// TODO: host, port, wms name and layer name as variable
// Erzeugen der Symbole und Update der Daten in der Datenbank. Es wird ein WMS-Server benötigt.
task updateSymbols(type: OerebIconizerQgis3) {
    description = "Erzeugt die Symbole und den Text für die einzelnen Legendeneinträge."
    sldUrl = "http://localhost:3000/qgis/ch.so.arp.nutzungsplanung.oereb?&SERVICE=WMS&REQUEST=GetStyles&LAYERS=grundnutzung&SLD_VERSION=1.1.0"
    legendGraphicUrl = "http://localhost:3000/qgis/ch.so.arp.nutzungsplanung.oereb?SERVICE=WMS&REQUEST=GetLegendGraphic&LAYER=grundnutzung&FORMAT=image/png&RULELABEL=false&LAYERTITLE=false&HEIGHT=35&WIDTH=70&SYMBOLHEIGHT=3&SYMBOLWIDTH=6&DPI=300"
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    dbQTable = "agi_oereb_npl_staging.transferstruktur_legendeeintrag"
    typeCodeAttrName = "artcode"
    symbolAttrName = "symbol"
    legendTextAttrName = "legendetext_de"

/*
    finalizedBy {
        stopWMSDockerContainer
    }
*/
}

// Daten in eine INTERLIS-Datei exportieren.
task exportLandUsePlans(type: Ili2pgExport) {
    description = "Exportiert die umgebauten Daten aus dem Staging-Schema ($dbSchemaLandUsePlansOerebStaging) in die Transferstruktur."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = "OeREBKRMtrsfr_V1_1"
    dbschema = "agi_oereb_npl_staging"
    dataFile = "ch.so.arp.nutzungsplanung.oereb.xtf"
    dataset = "ch.so.arp.nutzungsplanung"

}

// Lädt die kantonalen Gesetze herunter und importiert sie in das ÖREB-NPL-Staging-Schema.
task downloadCantonalLegalBasis(type: Download) {
    description = "Download kantonale Gesetze ($cantonalLegalBaseDataSet)."
    group = GROUP
    src cantonalLegalBasisBaseUrl + cantonalLegalBaseDataSet + ".xml"
    dest pathToTempFolder
    overwrite true

    doLast {
        println "File downloaded to: " + pathToTempFolder
    }        
}

task importCantonalLegalBasisToStaging(type: Ili2pgReplace, dependsOn: 'downloadCantonalLegalBasis') {
    description = "Import kantonale Gesetze ($cantonalLegalBaseDataSet)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelVorschriften
    dbschema = dbSchemaLandUsePlansOerebStaging
    dataFile = file(Paths.get(pathToTempFolder.toString(), cantonalLegalBaseDataSet + ".xml"))
    dataset = "ch.so.sk.legal_basis" // Anderes (in diesem Fall beliebig) Dataset, da die dazugehörigen Daten nicht Bestandteil des Transfers (des exportierten Files) sein dürfen.
    disableValidation = true
}

// Lädt die Daten der zuständigen Stellen der Nutzungsplanung herunter und importiert diese in das
// ÖREB-NPL-Staging-Schema.
task downloadResponsibleOffices(type: Download) {
    description = "Download zuständige Stellen ($responsibleOfficesDataSet)."
    group = GROUP
    src responsibleOfficesBaseUrl + responsibleOfficesDataSet + ".xtf"
    dest pathToTempFolder
    overwrite true

    doLast {
        println "File downloaded to: " + pathToTempFolder
    }        
}

task importResponsibleOfficesToStaging(type: Ili2pgReplace, dependsOn: 'downloadResponsibleOffices') {
    description = "Import zuständige Stellen ($responsibleOfficesDataSet)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelTransferstruktur
    dbschema = dbSchemaLandUsePlansOerebStaging
    dataFile = file(Paths.get(pathToTempFolder.toString(), responsibleOfficesDataSet + ".xtf"))
    dataset = "ch.so.arp.nutzungsplanung" // Gleiches Dataset wie anschliessend die Daten des Datenumbaues, da Ämterinformationen Bestandteil des Transfers sein müssen. TODO: Herausforderung pro Gemeinde in Verbindung mit der/den fehlenden zuständigen Stelle(n)
    disableValidation = true
}

// QGIS-Iconizer-Image erstellen und Container hochfahren
import java.text.SimpleDateFormat
import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.container.DockerRemoveContainer
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer.ExposedPort
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStopContainer
import com.bmuschko.gradle.docker.tasks.container.DockerLogsContainer
import com.bmuschko.gradle.docker.tasks.container.extras.DockerWaitHealthyContainer

task buildWMSDockerImage(type: DockerBuildImage) {
    description = "Build docker image."
    inputDir = file("qgis-iconizer")
    tags = ["edigonzales/oereb-qgis-iconizer:"+version.toString(), "edigonzales/oereb-qgis-iconizer:latest"]

    doLast {
        println projectDir
    }    
}

task createWMSDockerContainer(type: DockerCreateContainer) {
    dependsOn 'buildWMSDockerImage'
    dependsOn 'removeWMSDockerContainer'

    description = "Create docker container."
    targetImageId buildWMSDockerImage.getImageId()
    containerName = "oereb-qgis-iconizer"
    portBindings = ['3000:80']
    exposedPorts = [new ExposedPort("tcp", [80])]
    binds = [(projectDir.toString()+"/qgis-iconizer/data"):"/data"]
}

task removeWMSDockerContainer(dependsOn: 'buildWMSDockerImage', type: DockerRemoveContainer) {
    description = "Remove existing docker container."
    removeVolumes = true
    force = true
    targetContainerId createWMSDockerContainer.containerName 

    onError { exception -> 
        println exception.message
    }
}

task startWMSDockerContainer(dependsOn: 'createWMSDockerContainer', type: DockerStartContainer) {	
    description = "Start docker container."
    targetContainerId createWMSDockerContainer.getContainerId()

    /*
    finalizedBy {
        logDockerContainer
    }
    */

    // Since there is no proper healthcheck at the moment,
    // we wait 10 seconds.
    doLast {
        println "Wait for QGIS-Server..."
        sleep(10000)
    }
}

task stopWMSDockerContainer(type: DockerStopContainer) {
    description = "Stop docker container."
    targetContainerId startWMSDockerContainer.getContainerId()
}