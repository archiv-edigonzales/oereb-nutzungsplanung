buildscript {
    repositories {
        //mavenLocal()
        maven { url "http://download.osgeo.org/webdav/geotools/" }
        jcenter()
        mavenCentral()
        maven { url "http://jars.interlis.ch" }
    }
    /*
    dependencies {
       classpath "ch.so.agi:gretl:2.0.9999"
    } 
    */   
}

plugins {
    id "ch.so.agi.gretl" version "2.0.121"
    id "de.undercouch.download" version "3.4.3"
    id "com.bmuschko.docker-remote-api" version "4.10.0"
    id "jp.classmethod.aws" version "0.40"
}

//apply plugin: "ch.so.agi.gretl"
apply plugin: "jp.classmethod.aws.s3"

import java.nio.file.Paths
import ch.so.agi.gretl.tasks.*

ext {
    dbUriEdit = "jdbc:postgresql://localhost:54322/edit"
    dbUserEdit = "gretl"
    dbPwdEdit = "gretl"

    iliModelLandUsePlans = "SO_Nutzungsplanung_20171118"
    dbSchemaLandUsePlans = "arp_npl"

    iliModelVorschriften = "OeREBKRMvs_V1_1"
    iliModelTransferstruktur = "OeREBKRMtrsfr_V1_1"
    dbSchemaLandUsePlansOereb = "arp_npl_oereb"

    //bintrayUser = System.getenv('bintrayUser')
    //bintrayKey = System.getenv('bintrayKey')
}

aws {
	profileName = "default"
	region = "eu-central-1"
}


def pathToTempFolder = System.getProperty("java.io.tmpdir")

def federalLegalBasisBaseUrl = "http://models.geo.admin.ch/V_D/OeREB/"
def federalLegalBaseDataSet = "OeREBKRM_V1_1_Gesetze_20180501"

def cantonalLegalBasisBaseUrl = "https://geo.so.ch/geodata/ch.so.sk.gesetze.oereb/"
def cantonalLegalBaseDataSet = "ch.so.sk.gesetze"

def responsibleOfficesBaseUrl = "https://geo.so.ch/geodata/ch.so.agi.zustaendigestellen.oereb/"
def responsibleOfficesDataSet = "ch.so.agi.zustaendigestellen"

def GROUP = "Datenumbau NPLSO -> Transferstruktur (Oereb-Schema)"

// Löscht sämtliche Daten aus dem ÖREB-NPL-Schema in der Edit-DB.
task deleteFromOereb(type: SqlExecutor) {
    description = "Löscht die Daten aus dem OEREB-Schema ($dbSchemaLandUsePlansOereb)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    sqlFiles = ["delete_oereb_landuseplans_tables.sql"]
}

// Macht den Datenumbau aus dem kantonalen Modell der NPL in die Transferstruktur im ÖREB-NPL-OEREB-Schema.
task insertToOereb(type: SqlExecutor, dependsOn: 'deleteFromOereb') {
    description = "Baut die Daten aus dem kantonalen Modell in das Rahmenmodell (Transferstruktur) um und speichert sie im OEREB-Schema ($dbSchemaLandUsePlansOereb)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    //sqlFiles = ["wip-insert_oereb_landuseplans_tables.sql"]
    sqlFiles = ["insert_oereb_landuseplans_tables.sql"]
}

// TODO: für jeden Nutzungstyp ("Layer").
// TODO: host, port, wms name and layer name as variable
// Erzeugen der Symbole und Update der Daten in der Datenbank. Es wird ein WMS-Server benötigt.
task updateSymbolsGrundnutzung(type: OerebIconizerQgis3) {
    description = "Erzeugt die Symbole und den Text für die einzelnen Legendeneinträge."
    sldUrl = "http://localhost:8083/wms/oereb-symbols?&SERVICE=WMS&REQUEST=GetStyles&LAYERS=ch.so.Nutzungsplanung.NutzungsplanungGrundnutzung&SLD_VERSION=1.1.0"
    legendGraphicUrl = "http://localhost:8083/wms/oereb-symbols?SERVICE=WMS&REQUEST=GetLegendGraphic&LAYER=ch.so.Nutzungsplanung.NutzungsplanungGrundnutzung&FORMAT=image/png&RULELABEL=false&LAYERTITLE=false&HEIGHT=35&WIDTH=70&SYMBOLHEIGHT=3&SYMBOLWIDTH=6&DPI=300"
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    dbQTable = "arp_npl_oereb.transferstruktur_legendeeintrag"
    typeCodeAttrName = "artcode"
    symbolAttrName = "symbol"
    useCommunalTypeCodes = true

/*
    finalizedBy {
        stopWMSDockerContainer
    }
*/
}

// Daten in eine INTERLIS-Datei exportieren.
task exportLandUsePlansOereb(type: Ili2pgExport) {
    description = "Exportiert die umgebauten Daten aus dem OEREB-Schema ($dbSchemaLandUsePlansOereb) in die Transferstruktur."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = "OeREBKRMtrsfr_V1_1"
    dbschema = "arp_npl_oereb"
    dataFile = "$rootDir/" + "ch.so.arp.nutzungsplanung.oereb.xtf"
    dataset = "ch.so.arp.nutzungsplanung"
    disableValidation = true
}

/*
task uploadToBintray() {
    description = "Lädt die Daten auf Bintray hoch und publiziert sie."
    doLast {
        def bintrayLogin = bintrayUser + ":" + bintrayKey
        def fileName = "$rootDir/" + "ch.so.arp.nutzungsplanung.oereb.xtf"
        def responseUpload = ["curl", "-u", bintrayLogin, "-T", fileName,
                        "https://api.bintray.com/content/sogis/ch.so.agi.oereb-data/ch.so.arp.nutzungsplanung.oereb/latest/ch.so.arp.nutzungsplanung.oereb.xtf?override=1"].execute().text
        println(responseUpload)

        def responsePublish = ["curl", "-u", bintrayLogin, "-X", "POST",
                        "https://api.bintray.com/content/sogis/ch.so.agi.oereb-data/ch.so.arp.nutzungsplanung.oereb/latest/publish"].execute().text
        println(responsePublish)
    }
}
*/

import com.amazonaws.services.s3.model.ObjectMetadata
import jp.classmethod.aws.gradle.s3.AmazonS3FileUploadTask

task uploadToS3(type: AmazonS3FileUploadTask) {
	file file("$rootDir/" + "ch.so.arp.nutzungsplanung.oereb.xtf") // must be a file
	bucketName "ch.so.arp.nutzungsplanung.oereb-dev"
	key "ch.so.arp.nutzungsplanung.oereb.xtf"

	def m = new ObjectMetadata()
	m.setCacheControl("no-cache, no-store")
	objectMetadata = m
}

// Lädt die Bundesgesetze herunter und importiert sie in das ÖREB-NPL-OEREB-Schema.
task downloadFederalLegalBasis(type: Download) {
    description = "Download Bundesgesetze ($federalLegalBaseDataSet)."
    group = GROUP
    src federalLegalBasisBaseUrl + federalLegalBaseDataSet + ".xml"
    dest pathToTempFolder
    overwrite true

    doLast {
        println "File downloaded to: " + pathToTempFolder
    }        
}

task importFederalLegalBasisToOereb(type: Ili2pgReplace, dependsOn: 'downloadFederalLegalBasis') {
    description = "Import Bundesgesetze ($federalLegalBaseDataSet)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelVorschriften
    dbschema = dbSchemaLandUsePlansOereb
    dataFile = file(Paths.get(pathToTempFolder.toString(), federalLegalBaseDataSet + ".xml"))
    dataset = "ch.admin.bk.gesetze" // Anderes (in diesem Fall beliebig) Dataset, da die dazugehörigen Daten nicht Bestandteil des Transfers (des exportierten Files) sein dürfen.
    disableValidation = true
}

// Lädt die kantonalen Gesetze herunter und importiert sie in das ÖREB-NPL-OEREB-Schema.
task downloadCantonalLegalBasis(type: Download) {
    description = "Download kantonale Gesetze ($cantonalLegalBaseDataSet)."
    group = GROUP
    src cantonalLegalBasisBaseUrl + cantonalLegalBaseDataSet + ".xtf"
    dest pathToTempFolder
    overwrite true

    doLast {
        println "File downloaded to: " + pathToTempFolder
    }        
}

task importCantonalLegalBasisToOereb(type: Ili2pgReplace, dependsOn: 'downloadCantonalLegalBasis') {
    description = "Import kantonale Gesetze ($cantonalLegalBaseDataSet)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelVorschriften
    dbschema = dbSchemaLandUsePlansOereb
    dataFile = file(Paths.get(pathToTempFolder.toString(), cantonalLegalBaseDataSet + ".xtf"))
    dataset = cantonalLegalBaseDataSet // Anderes (in diesem Fall beliebig) Dataset, da die dazugehörigen Daten nicht Bestandteil des Transfers (des exportierten Files) sein dürfen.
    disableValidation = true
}

// Lädt die Daten der zuständigen Stellen der Nutzungsplanung herunter und importiert diese in das
// ÖREB-Rahmenmodell-NPL-Schema.
task downloadResponsibleOffices(type: Download) {
    description = "Download zuständige Stellen ($responsibleOfficesDataSet)."
    group = GROUP
    src responsibleOfficesBaseUrl + responsibleOfficesDataSet + ".xtf"
    dest pathToTempFolder
    overwrite true

    doLast {
        println "File downloaded to: " + pathToTempFolder
    }        
}

task importResponsibleOfficesToOereb(type: Ili2pgReplace, dependsOn: 'downloadResponsibleOffices') {
    description = "Import zuständige Stellen ($responsibleOfficesDataSet)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelTransferstruktur
    dbschema = dbSchemaLandUsePlansOereb
    dataFile = file(Paths.get(pathToTempFolder.toString(), responsibleOfficesDataSet + ".xtf"))
    dataset = "ch.so.arp.nutzungsplanung" // Gleiches Dataset wie anschliessend die Daten des Datenumbaues, da Ämterinformationen Bestandteil des Transfers sein müssen. 
    disableValidation = true
}

// QGIS-Iconizer-Image erstellen und Container hochfahren
import java.text.SimpleDateFormat
import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPullImage
import com.bmuschko.gradle.docker.tasks.container.DockerRemoveContainer
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer.ExposedPort
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStopContainer
import com.bmuschko.gradle.docker.tasks.container.DockerLogsContainer
import com.bmuschko.gradle.docker.tasks.container.extras.DockerWaitHealthyContainer

task pullWMSDockerImage(type: DockerPullImage) {
    repository = "sogis/oereb-wms"
    tag = "latest"
}

task createWMSDockerContainer(dependsOn: 'pullWMSDockerImage', type: DockerCreateContainer) {
    //dependsOn 'buildWMSDockerImage'
    dependsOn 'removeWMSDockerContainer'

    description = "Create docker container."
    image = "sogis/oereb-wms:latest"
    imageId = "oereb-qgis-iconizer"
    containerName = "oereb-qgis-iconizer"
    portBindings = ['8083:80']
    exposedPorts = [new ExposedPort("tcp", [80])]
    envVars.set(["QGIS_SERVER_PARALLEL_RENDERING": "true",
               "QGIS_SERVER_MAX_THREADS": "2",
               "QGIS_FCGI_MIN_PROCESSES": "1",
               "QGIS_FCGI_MAX_PROCESSES": "1",
               "QGIS_SERVER_LOG_LEVEL": "0"])
    //binds = [(projectDir.toString()+"/qgis-iconizer/qgis"):"/data"]
}

//task removeWMSDockerContainer(dependsOn: 'buildWMSDockerImage', type: DockerRemoveContainer) {
task removeWMSDockerContainer(type: DockerRemoveContainer) {
    description = "Remove existing docker container."
    removeVolumes = true
    force = true
    targetContainerId createWMSDockerContainer.containerName 

    onError { exception -> 
        println exception.message
    }
}

task startWMSDockerContainer(dependsOn: 'createWMSDockerContainer', type: DockerStartContainer) {	
    description = "Start docker container."
    targetContainerId createWMSDockerContainer.getContainerId()

    /*
    finalizedBy {
        logDockerContainer
    }
    */

    // Since there is no proper healthcheck at the moment,
    // we wait 10 seconds.
    doLast {
        println "Wait for QGIS-Server..."
        sleep(10000)
    }
}

task stopWMSDockerContainer(type: DockerStopContainer) {
    description = "Stop docker container."
    targetContainerId startWMSDockerContainer.getContainerId()
}